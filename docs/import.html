<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>CV Import Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex, nofollow, noai, noimageai, noimageindex">

  <!-- Simple styling so it's not ugly -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 2rem;
      display: flex;
      justify-content: center;
    }

    .import-container {
      background: #ffffff;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
      max-width: 600px;
      width: 100%;
    }

    h1 {
      margin-top: 0;
      font-size: 1.5rem;
    }

    .field {
      margin-bottom: 1rem;
    }

    label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
      font-weight: 600;
    }

    input[type="text"],
    input[type="file"] {
      width: 100%;
      font-size: 0.95rem;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    input[type="file"] {
      padding: 0.3rem 0.75rem;
    }

    button {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.6rem 1.2rem;
      border-radius: 999px;
      border: none;
      background: #2563eb;
      color: #ffffff;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
    }

    button[disabled] {
      opacity: 0.6;
      cursor: default;
    }

    /* Secondary button style for "Test data" */
    .button-secondary {
      background: #e5e7eb;
      color: #111827;
    }

    .button-secondary:hover:not([disabled]) {
      background: #d1d5db;
    }

    .status {
      margin-top: 1rem;
      font-size: 0.9rem;
    }

    .status--error {
      color: #b91c1c;
    }

    .status--success {
      color: #166534;
    }

    .preview {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 8px;
      background: #f3f4f6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
      max-height: 300px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
  </style>
</head>

<body>
  <div class="import-container">
    <h1>Import CV Translations</h1>
    <p style="font-size:0.9rem; color:#4b5563;">
      This tool imports a JSON file into Firestore collection
      <code>cvs</code>. The document ID will be the password/key you enter.
    </p>

    <div class="field">
      <label for="passwordInput">Password / Key (document ID)</label>
      <input type="text" id="passwordInput" placeholder="e.g. my-secret-password" />
    </div>

    <div class="field">
      <label for="fileInput">JSON file</label>
      <input type="file" id="fileInput" accept="application/json" />
      <small style="font-size:0.8rem; color:#6b7280;">
        Expected JSON: either
        <code>{ "en": {...}, "lt": {...} }</code>
        or
        <code>{ "translations": { "en": {...}, "lt": {...} } }</code>
        or a full document like
        <code>{ "profileImage": "...", "translations": { "en": {...}, "lt": {...} } }</code>.
      </small>
    </div>

    <div class="field button-row">
      <button id="importButton">Import to Firestore</button>
      <button id="testButton" type="button" class="button-secondary">
        Test data (merge preview)
      </button>
      <button id="copyButton" type="button" class="button-secondary" disabled>
        Copy data
      </button>
    </div>

    <div id="status" class="status"></div>

    <div id="preview" class="preview" style="display:none;"></div>
  </div>

  <!-- Firebase Compat SDKs (same as in index.html) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- Your existing Firebase config, same file used by CV page -->
  <script src="firebaseConfig.js"></script>

  <script>
    let lastPreviewJson = null;
    // Simple helper to show status messages
    function setStatus(message, type) {
      const el = document.getElementById("status");
      el.textContent = message || "";
      el.className = "status";
      if (type === "error") el.classList.add("status--error");
      if (type === "success") el.classList.add("status--success");
    }

    // Recursively sort object keys so JSON preview is stable
    function sortObjectDeep(value) {
      if (Array.isArray(value)) {
        return value.map(sortObjectDeep);
      }

      if (value && typeof value === "object") {
        const sortedKeys = Object.keys(value).sort();
        const result = {};
        sortedKeys.forEach((key) => {
          result[key] = sortObjectDeep(value[key]);
        });
        return result;
      }

      return value;
    }

    // Preview helper, now with optional note/meta
    function setPreview(obj, note) {
      const previewEl = document.getElementById("preview");
      const copyButton = document.getElementById("copyButton");

      if (!obj) {
        previewEl.style.display = "none";
        previewEl.textContent = "";
        lastPreviewJson = null;
        if (copyButton) copyButton.disabled = true;
        return;
      }

      // Create a deterministically ordered copy
      const sorted = sortObjectDeep(obj);

      // Save full sorted JSON for clipboard
      lastPreviewJson = JSON.stringify(sorted, null, 2);
      if (copyButton) copyButton.disabled = false;

      previewEl.style.display = "block";
      const keys = Object.keys(sorted);
      let header = "Top-level keys (sorted): " + JSON.stringify(keys);
      if (note) {
        header = note + "\n\n" + header;
      }

      previewEl.textContent =
        header +
        "\n\nPreview:\n" +
        lastPreviewJson; // still show same JSON
    }



    // Build a CV document from parsed JSON using same expectations as import
    function buildCvDocFromParsedJson(json) {
      if (!json || typeof json !== "object" || Array.isArray(json)) {
        throw new Error("Parsed JSON does not look like an object.");
      }

      // If JSON already has a "translations" object, treat the whole JSON as the document
      if (Object.prototype.hasOwnProperty.call(json, "translations")) {
        const translations = json.translations;
        if (
          !translations ||
          typeof translations !== "object" ||
          Array.isArray(translations)
        ) {
          throw new Error(
            '"translations" field must be an object (e.g. { "en": {...}, "lt": {...} }).'
          );
        }
        return json;
      }

      // Legacy: treat JSON as translations map
      const translations = json;
      if (
        !translations ||
        typeof translations !== "object" ||
        Array.isArray(translations)
      ) {
        throw new Error(
          "Parsed JSON does not look like an object of translations."
        );
      }

      return {
        translations: translations,
      };
    }

    // --- Merge helpers (same semantics as CV UI) ---

    function mergeContentObjects(baseObj, overrideObj) {
      if (!baseObj && !overrideObj) return {};
      if (!baseObj)
        return Array.isArray(overrideObj)
          ? overrideObj.slice()
          : { ...overrideObj };
      if (!overrideObj)
        return Array.isArray(baseObj)
          ? baseObj.slice()
          : { ...baseObj };

      const result = Array.isArray(baseObj) ? baseObj.slice() : { ...baseObj };

      Object.keys(overrideObj).forEach((key) => {
        const baseVal = baseObj[key];
        const overrideVal = overrideObj[key];

        // Arrays: items from nested go first, then base
        if (Array.isArray(overrideVal)) {
          if (Array.isArray(baseVal)) {
            result[key] = overrideVal.slice().concat(baseVal);
          } else {
            result[key] = overrideVal.slice();
          }
          return;
        }

        // Plain objects: shallow-deep merge
        if (
          overrideVal &&
          typeof overrideVal === "object" &&
          !Array.isArray(overrideVal)
        ) {
          if (
            baseVal &&
            typeof baseVal === "object" &&
            !Array.isArray(baseVal)
          ) {
            result[key] = mergeContentObjects(baseVal, overrideVal);
          } else {
            result[key] = { ...overrideVal };
          }
          return;
        }

        // Primitives / null: nested overrides base
        result[key] = overrideVal;
      });

      return result;
    }

    function mergeCvTranslations(baseTranslations, overrideTranslations) {
      const merged = {};
      const baseKeys = baseTranslations ? Object.keys(baseTranslations) : [];
      const overrideKeys = overrideTranslations
        ? Object.keys(overrideTranslations)
        : [];
      const allLangs = new Set([...baseKeys, ...overrideKeys]);

      allLangs.forEach((lang) => {
        const baseT =
          (baseTranslations && baseTranslations[lang]) || {};
        const overrideT =
          (overrideTranslations && overrideTranslations[lang]) || {};
        merged[lang] = mergeContentObjects(baseT, overrideT);
      });

      return merged;
    }

    // Resolve useBaseCV in the import tool (one level of nesting)
    async function resolveCvForImport(requestedKey, directDoc) {
      const direct = directDoc || {};
      const directTranslations = direct.translations || {};
      const directProfileImage = direct.profileImage || null;
      const baseKey = direct.useBaseCV;

      const meta = {
        usedBase: false,
        baseKey: baseKey || null,
        baseFound: false,
        baseAllowAsBase: false,
        baseHasOwnBase: false,
        warning: null,
      };

      // No useBaseCV: just use direct data
      if (!baseKey) {
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      if (baseKey === requestedKey) {
        meta.warning = "useBaseCV points to the same key; ignoring useBaseCV.";
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      if (typeof firebase === "undefined" || !firebase.firestore) {
        meta.warning =
          "Firebase is not initialized; cannot load useBaseCV from Firestore.";
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      const dbRef = firebase.firestore();
      let baseSnap;
      try {
        baseSnap = await dbRef.collection("cvs").doc(baseKey).get();
      } catch (e) {
        console.error("Failed to fetch base CV:", e);
        meta.warning = "Failed to fetch base CV from Firestore.";
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      if (!baseSnap.exists) {
        meta.warning = 'Base CV not found for key "' + baseKey + '".';
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      const baseData = baseSnap.data() || {};
      meta.baseFound = true;

      // Only CVs marked allowAsBase can be used as base
      if (!baseData.allowAsBase) {
        meta.warning =
          'Base CV "' +
          baseKey +
          '" exists but allowAsBase is not true; ignoring base.';
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      meta.baseAllowAsBase = true;

      // One level of nesting only
      if (baseData.useBaseCV) {
        meta.baseHasOwnBase = true;
        meta.warning =
          'Base CV "' +
          baseKey +
          '" itself has useBaseCV; nested bases are not supported.';
        return {
          translations: directTranslations,
          profileImage: directProfileImage,
          meta,
        };
      }

      const baseTranslations = baseData.translations || {};
      const mergedTranslations = mergeCvTranslations(
        baseTranslations,
        directTranslations
      );

      const mergedProfile =
        directProfileImage || baseData.profileImage || null;

      meta.usedBase = true;
      meta.warning = null;

      return {
        translations: mergedTranslations,
        profileImage: mergedProfile,
        meta,
      };
    }

    document
      .getElementById("importButton")
      .addEventListener("click", async () => {
        const passwordInput = document.getElementById("passwordInput");
        const fileInput = document.getElementById("fileInput");
        const importButton = document.getElementById("importButton");

        const key = (passwordInput.value || "").trim();
        const file = fileInput.files[0];

        setStatus("", null);
        setPreview(null);

        if (!key) {
          setStatus("Please enter a password/key (document ID).", "error");
          return;
        }
        if (!file) {
          setStatus("Please select a JSON file to import.", "error");
          return;
        }

        if (typeof firebase === "undefined" || !firebase.firestore) {
          setStatus(
            "Firebase is not initialized. Check firebaseConfig.js inclusion.",
            "error"
          );
          return;
        }

        importButton.disabled = true;
        setStatus("Reading file...", null);

        try {
          const text = await file.text();
          let parsed;
          try {
            parsed = JSON.parse(text);
          } catch (e) {
            setStatus("File is not valid JSON: " + e.message, "error");
            importButton.disabled = false;
            return;
          }

          let cvDoc;
          try {
            cvDoc = buildCvDocFromParsedJson(parsed);
          } catch (e) {
            setStatus(e.message, "error");
            importButton.disabled = false;
            return;
          }

          // Show preview of the raw document (this is exactly what will be stored)
          setPreview(cvDoc);
          setStatus("Uploading to Firestore...", null);

          const dbRef = firebase.firestore();

          await dbRef.collection("cvs").doc(key).set(cvDoc, {
            merge: false, // overwrite doc completely
          });

          setStatus(
            'Import successful. Document saved as "cvs/' + key + '".',
            "success"
          );
        } catch (err) {
          console.error(err);
          setStatus("Import failed: " + err.message, "error");
        } finally {
          importButton.disabled = false;
        }
      });

    // --- Test data (merged preview) ---

    document
      .getElementById("testButton")
      .addEventListener("click", async () => {
        const passwordInput = document.getElementById("passwordInput");
        const fileInput = document.getElementById("fileInput");
        const testButton = document.getElementById("testButton");

        const key = (passwordInput.value || "").trim();
        const file = fileInput.files[0] || null;

        setStatus("", null);
        setPreview(null);

        if (!key) {
          setStatus("Please enter a password/key (document ID).", "error");
          return;
        }

        if (typeof firebase === "undefined" || !firebase.firestore) {
          setStatus(
            "Firebase is not initialized. Check firebaseConfig.js inclusion.",
            "error"
          );
          return;
        }

        const dbRef = firebase.firestore();
        testButton.disabled = true;

        try {
          let cvDoc;
          let sourceDescription;

          if (file) {
            // ---- MODE 1: test the selected JSON file (not yet imported) ----
            setStatus("Reading file for test...", null);
            const text = await file.text();
            let parsed;
            try {
              parsed = JSON.parse(text);
            } catch (e) {
              setStatus("File is not valid JSON: " + e.message, "error");
              return;
            }

            try {
              cvDoc = buildCvDocFromParsedJson(parsed);
            } catch (e) {
              setStatus(e.message, "error");
              return;
            }

            sourceDescription =
              'Source: JSON file (not yet imported) for key "' + key + '".';
          } else {
            // ---- MODE 2: test existing Firestore document by key only ----
            setStatus(
              'Loading existing CV "cvs/' + key + '" from Firestore for test...',
              null
            );

            const snap = await dbRef.collection("cvs").doc(key).get();
            if (!snap.exists) {
              setStatus(
                'No existing document found for key "' + key + '" in collection "cvs".',
                "error"
              );
              return;
            }

            cvDoc = snap.data() || {};
            sourceDescription =
              'Source: existing Firestore document "cvs/' + key + '".';
          }

          // Resolve with useBaseCV (if any) using same rules as CV UI
          const resolved = await resolveCvForImport(key, cvDoc);

          const previewDoc = {
            profileImage: resolved.profileImage || null,
            translations: resolved.translations || {},
          };

          const baseKey = cvDoc.useBaseCV;
          let noteLines = [sourceDescription];

          if (!baseKey) {
            noteLines.push(
              'Merged preview for "' +
              key +
              '". No useBaseCV specified; this CV will be used as-is.'
            );
          } else if (resolved.meta.usedBase) {
            noteLines.push(
              'Merged preview for "' +
              key +
              '". useBaseCV "' +
              baseKey +
              '" was FOUND and USED (allowAsBase: true).'
            );
          } else {
            noteLines.push(
              'Merged preview for "' +
              key +
              '". useBaseCV "' +
              baseKey +
              '" was NOT used.'
            );
            if (resolved.meta.warning) {
              noteLines.push("Reason: " + resolved.meta.warning);
            }
          }

          setPreview(previewDoc, noteLines.join("\n"));
          setStatus(
            "Test merge completed. See merged result in the preview.",
            "success"
          );
        } catch (err) {
          console.error(err);
          setStatus("Test failed: " + err.message, "error");
        } finally {
          testButton.disabled = false;
        }
      });

    document
      .getElementById("copyButton")
      .addEventListener("click", async () => {
        if (!lastPreviewJson) {
          setStatus("Nothing to copy yet. Run Import or Test first.", "error");
          return;
        }

        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(lastPreviewJson);
            setStatus("Sorted JSON copied to clipboard.", "success");
          } else {
            // Fallback: create a temporary textarea
            const ta = document.createElement("textarea");
            ta.value = lastPreviewJson;
            ta.style.position = "fixed";
            ta.style.opacity = "0";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            document.body.removeChild(ta);
            setStatus("Sorted JSON copied to clipboard.", "success");
          }
        } catch (err) {
          console.error(err);
          setStatus("Failed to copy to clipboard: " + err.message, "error");
        }
      });
  </script>
</body>

</html>